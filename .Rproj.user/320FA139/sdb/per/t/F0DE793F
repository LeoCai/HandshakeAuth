{
    "contents" : "I = matrix(\n  c(1,0,0,\n    0,1,0,\n    0,0,1),nrow = 3, ncol = 3, byrow = T\n)\n\nupdateMatrixByGYR = function(gyr, dt, cuMatrix) {\n  delta = as.numeric(sqrt((gyr[1] * dt) ^ 2 + (gyr[2] * dt) ^ 2 + (gyr[3] * dt) ^ 2))\n  if(delta == 0) return(cuMatrix);\n  B = matrix(\n    c(\n      as.numeric(0), as.numeric(-gyr[3] * dt), as.numeric(gyr[2] * dt),\n      as.numeric(gyr[3] * dt), as.numeric(0), as.numeric(-gyr[1] * dt),\n      as.numeric(-gyr[2] * dt), as.numeric(gyr[1] * dt), as.numeric(0)\n    ),\n    nrow = 3, ncol = 3, byrow = TRUE\n  )\n  B1 = B * (sin(delta) / delta)\n  B2 = (1 - cos(delta)) / (delta ^ 2) * (B %*% B)\n  updateMatrix = I + B1 + B2\n  return(cuMatrix %*% updateMatrix)\n}\n\nupdateMatrixByMultiGYR = function(gyrs, initMatrix,dt) {\n  cuMatrix = initMatrix\n  matrixs = list()\n  (lenG = nrow(gyrs))\n  for (i in 1:lenG) {\n   # cuMatrix = updateMatrixByGYR(gyrs[i,1:3],gyrs[i,4],cuMatrix)\n    cuMatrix = updateMatrixByGYR(gyrs[i,1:3],dt,cuMatrix)\n    matrixs = rbind(matrixs,as.vector(cuMatrix))\n  }\n  return (matrixs)\n}\n\ngetGlobleAccs = function(accs, rtMats) {\n  globleAccs = list()\n  for(i in 1:nrow(accs)){\n    rtMat = matrix(as.numeric(rtMats[i,]), nrow= 3, ncol = 3 )\n    glaccs = rtMat %*% matrix(\n      as.numeric(accs[i,]),nrow = 3, ncol = 1, byrow = T\n    )\n    globleAccs = rbind(globleAccs,as.numeric(c(glaccs[1,],glaccs[2,],glaccs[3,])))\n  }\n  return (globleAccs)\n}\n\ngetInitMatrix = function(gaccInit, initTheta) {\n  vgaccInit = as.numeric(c(gaccInit[1],gaccInit[2],gaccInit[3]))\n  normGcc = vgaccInit / (norm(vgaccInit,type = \"2\"))\n  gx = normGcc[1]\n  gy = normGcc[2]\n  gz = normGcc[3]\n  r = 1\n  fi = pi/2 - atan2(sqrt(gx ^ 2 + gy ^ 2),gz)\n  theta = initTheta\n  xInit = convertFromSphericalToCardinal(r,fi,theta)\n  xInit = xInit / (norm(matrix(xInit),type = \"2\"))\n  yInit = product(normGcc,xInit)                     #wrong!!!!\n  yInit = yInit / (norm(matrix(yInit),type = \"2\"))\n  initMatrix = matrix(\n    c(gx,gy,gz,\n      xInit[1],xInit[2],xInit[3],\n      yInit[1],yInit[2],yInit[3]),\n    nrow = 3,ncol = 3\n  )\n  return (initMatrix)\n}\n\nconvertFromSphericalToCardinal = function(r, fi, theta) {\n  x = r * sin(fi) * cos(theta)\n  y = r * sin(fi) * sin(theta)\n  z = r * cos(fi)\n  return(c(x,y,z))\n}\n\nproduct <- function(x, y, i=1:3) {\n  # Project inputs into 3D, since the cross product only makes sense in 3D.\n  To3D <- function(x) head(c(x, rep(0, 3)), 3)\n  x <- To3D(x)\n  y <- To3D(y)\n  \n  # Indices should be treated cyclically (i.e., index 4 is \"really\" index 1, and\n  # so on).  Index3D() lets us do that using R's convention of 1-based (rather\n  # than 0-based) arrays.\n  Index3D <- function(i) (i - 1) %% 3 + 1\n  \n  # The i'th component of the cross product is:\n  # (x[i + 1] * y[i + 2]) - (x[i + 2] * y[i + 1])\n  # as long as we treat the indices cyclically.\n  return (x[Index3D(i + 1)] * y[Index3D(i + 2)] -\n            x[Index3D(i + 2)] * y[Index3D(i + 1)])\n}\n\ngetInitMatrix(c(2,1,0), 0)\n\nupdateMatrixByGYR(c(0,pi,0), 0.5, I)\n\n#convertFromSphericalToCardinal(1,pi/2,0)\n",
    "created" : 1451354521231.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1833834020",
    "id" : "F0DE793F",
    "lastKnownWriteTime" : 1451994010,
    "path" : "~/workspace/R/handshake_9_11/model/GloableConvert.R",
    "project_path" : "model/GloableConvert.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "type" : "r_source"
}